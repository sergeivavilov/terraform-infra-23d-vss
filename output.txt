.
├── README.md
├── eks-module
│   ├── configmap.tf
│   ├── eks.tf
│   ├── outputs.tf
│   ├── variables.tf
│   └── workers.tf
├── github copy
├── nginx-deployment.yaml
├── output.txt
├── plan-output.txt
├── rds-postgres-module
│   ├── rds.tf
│   └── vars.tf
└── root
    └── main-eks-root
        ├── homework-project-vss.tfvars
        ├── main.tf
        ├── mainvars.tf
        └── providers.tf

6 directories, 15 files
.github/workflows/terraform-deploy.yaml
# THIS IS .github/workflows/terraform-deploy.yaml

name: Terraform Deployment Workflow

on:
  push:
    branches: ["*"]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ (github.ref == 'refs/heads/main' && 'dev') || (github.ref == 'refs/heads/prod' && 'production') }}
    env:
      AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-region: us-east-1
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          role-session-name: GitHubActions

      - name: Initialize Terraform
        run: terraform init
        working-directory: ./root/main-eks-root

      - name: Plan Terraform
        id: plan
        run: terraform plan -var-file="homework-project-vss.tfvars" -out=tfplan -no-color > plan-output.txt
        working-directory: ./root/main-eks-root

      - name: Upload Terraform Plan Output
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v2
        with:
          name: terraform-plan-output
          path: ./root/main-eks-root/plan-output.txt

      # Comment out the apply step to prevent resource creation
      # - name: Apply Terraform
      #   if: github.ref == 'refs/heads/main'
      #   run: terraform apply -auto-approve tfplan
      #   working-directory: ./root/main-eks-root

      # Add the destroy step
      - name: Terraform Destroy
        if: github.ref == 'refs/heads/main'
        run: terraform destroy -var-file="homework-project-vss.tfvars" -auto-approve
        working-directory: ./root/main-eks-root

# # THIS IS .github/workflows/terraform-deploy.yaml

# # Role_ARN is in secrets

# name: Terraform Deployment Workflow

# on:
#   # Triggers the workflow on push or pull request events but only for the "main" branch
#   push:
#     branches: ["*"]

#   # Allows you to run this workflow manually from the Actions tab
#   # workflow_dispatch:

# permissions:
#   id-token: write # This is required for requesting the JWT
#   contents: read  # This is required for actions/checkout

# jobs:
#   deploy:
#     runs-on: ubuntu-latest
#     environment: ${{ (github.ref == 'refs/heads/main' && 'dev') || (github.ref == 'refs/heads/prod' && 'production') }}
#     env:
#       AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v2
#       - name: Configure AWS Credentials
#         uses: aws-actions/configure-aws-credentials@v3
#         with:
#           aws-region: us-east-1
#           role-to-assume: ${{ env.AWS_ROLE_ARN }}
#           role-session-name: GitHubActions
#       # Additional steps follow
      
#       - name: clone repo 
#         uses: actions/checkout@v4

#       - name: initialize Terraform
#         run: terraform init 
#         working-directory: ./root/main-eks-root
    
#       - name: Plan Terraform
#         id: plan
#         run: |
#           terraform plan -var-file="homework-project-vss.tfvars" -out=tfplan -no-color > plan-output.txt
#           cat plan-output.txt
#         working-directory: ./root/main-eks-root
#         continue-on-error: true # This can be helpful to ensure the workflow continues even if the plan indicates changes

#       - name: Upload Terraform Plan Output
#         uses: actions/upload-artifact@v2
#         with:
#           name: terraform-plan-output
#           path: ./root/main-eks-root/plan-output.txt

#       # - name: execute terraform
#       #   run: terraform apply -auto-approve
#       #   working-directory: ./root/main-eks-root




# # THIS IS .github/workflows/terraform-deploy.yaml

# name: Terraform Deployment Workflow

# on:
#   push:
#     branches: ["*"]
#   workflow_dispatch:

# permissions:
#   id-token: write
#   contents: read

# jobs:
#   deploy:
#     runs-on: ubuntu-latest
#     environment: ${{ (github.ref == 'refs/heads/main' && 'dev') || (github.ref == 'refs/heads/prod' && 'production') }}
#     env:
#       AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v2
      
#       - name: Configure AWS Credentials
#         uses: aws-actions/configure-aws-credentials@v3
#         with:
#           aws-region: us-east-1
#           role-to-assume: ${{ env.AWS_ROLE_ARN }}
#           role-session-name: GitHubActions

#       - name: Initialize Terraform
#         run: terraform init
#         working-directory: ./root/main-eks-root

#       - name: Plan Terraform
#         id: plan
#         run: terraform plan -out=tfplan -no-color > plan-output.txt
#         working-directory: ./root/main-eks-root


#       # Comment out the apply step to prevent resource creation
#       # - name: Apply Terraform
#       #   if: github.ref == 'refs/heads/main'
#       #   run: terraform apply -auto-approve tfplan
#       #   working-directory: ./root/main-eks-root

#       - name: Upload Terraform Plan Output
#         if: github.event_name == 'push' && github.ref == 'refs/heads/main'
#         uses: actions/upload-artifact@v2
#         with:
#           name: terraform-plan-output
#           path: ./root/main-eks-root/plan-output.txt


#       # Add the destroy step
#       - name: Terraform Destroy
#         if: github.ref == 'refs/heads/main'
#         run: terraform destroy -var-file="homework-project-vss.tfvars" -auto-approve
#         working-directory: ./root/main-eks-root












# # THIS IS .github/workflows/terraform-deploy.yaml


# # Role_ARN is in secrets

# name: Terraform Deployment Workflow

# on:
#   # Triggers the workflow on push or pull request events but only for the "main" branch
#   push:
#     branches: ["*"]

#   # Allows you to run this workflow manually from the Actions tab
#   # workflow_dispatch:

# permissions:
#   id-token: write # This is required for requesting the JWT
#   contents: read  # This is required for actions/checkout


# jobs:
#   deploy:
#     runs-on: ubuntu-latest
#     environment: ${{ (github.ref == 'refs/heads/main' && 'dev') || (github.ref == 'refs/heads/prod' && 'production') }}
#     env:
#       AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v2
#       - name: Configure AWS Credentials
#         uses: aws-actions/configure-aws-credentials@v3
#         with:
#           aws-region: us-east-1
#           role-to-assume: ${{ env.AWS_ROLE_ARN }}
#           role-session-name: GitHubActions
#       # Additional steps follow


      
#       - name: clone repo 
#         uses: actions/checkout@v4

#       - name: initialize Terraform
#         run: terraform init 
#         working-directory: ./root/main-eks-root

    

#       - name: Plan Terraform
#         id: plan
#         run: |
#           terraform plan -out=tfplan -no-color > plan-output.txt
#           cat plan-output.txt
#         working-directory: ./root/main-eks-root
#         continue-on-error: true # This can be helpful to ensure the workflow continues even if the plan indicates changes

#       - name: Upload Terraform Plan Output
#         uses: actions/upload-artifact@v2
#         with:
#           name: terraform-plan-output
#           path: ./root/main-eks-root/plan-output.txt


#       # - name: execute terraform
#       #   run: terraform apply -auto-approve
#       #   working-directory: ./root/main-eks-root
./rds-postgres-module/rds.tf
resource "aws_db_instance" "reviews_app_db" {
  allocated_storage    = var.allocated_storage
  storage_type         = var.storage_type
  engine               = var.engine
  engine_version       = var.engine_version
  instance_class       = var.instance_class
  db_name              = var.db_name
  identifier           = var.identifier
  username             = var.rds_master_username
  password             = var.rds_master_password # Ensure this is managed securely
  #   manage_master_user_password = var.manage_master_user_password
  vpc_security_group_ids = [aws_security_group.rds_sg.id]
  db_subnet_group_name = aws_db_subnet_group.postgres_subnet_group.name

  backup_retention_period = var.backup_retention_period
  skip_final_snapshot     = var.skip_final_snapshot

  tags = {
    Name = var.rds_tags_name
  }
}

resource "aws_db_subnet_group" "postgres_subnet_group" {
  name       = "postgres_group"
  subnet_ids = var.subnet_ids

  tags = {
    Name = "My DB subnet group"
  }
}

resource "aws_security_group" "rds_sg" {
  name        = var.rds_sg_name
  description = var.rds_sg_description
  vpc_id      = var.rds_sg_vpc

  ingress {
    from_port       = var.rds_ingress_port
    to_port         = var.rds_ingress_port
    protocol        = var.rds_ingress_protocol
    security_groups = var.eks_cluster_sg_id
  }

  egress {
    from_port   = var.rds_egress_port
    to_port     = var.rds_egress_port
    protocol    = var.rds_egress_protocol
    cidr_blocks = var.rds_egress_cidr
  }

  tags = {
    Name = var.rds_sg_tags_name
  }
}




./rds-postgres-module/vars.tf
variable "eks_cluster_sg_id" {
  description = "Security group ID of the EKS cluster"
  type = list(string)
}

variable "subnet_ids" {
  description = "Subnet IDs for the RDS subnet group"
  type = list(string)
}

variable "allocated_storage" {
  description = "The allocated storage in gigabytes"
  type = number
}

variable "storage_type" {
  description = "The storage type (e.g., gp2, io1)"
  type = string
}

variable "engine" {
  description = "The database engine (e.g., postgres)"
  type = string
}

variable "engine_version" {
  description = "The database engine version"
  type = string
}

variable "instance_class" {
  description = "The instance class for the RDS instance"
  type = string
}

variable "db_name" {
  description = "The name of the database to create"
  type = string
}

variable "identifier" {
  description = "The identifier for the RDS instance"
  type = string
}

variable "rds_master_username" {
  description = "The master username for the RDS instance"
  type = string
}

variable "rds_master_password" {
  description = "The master password for the RDS instance"
  type = string
  sensitive = true
}

variable "manage_master_user_password" {
  description = "Whether to manage the master user password with AWS Secrets Manager"
  type = bool
  default = true
}

variable "backup_retention_period" {
  description = "The number of days to retain backups"
  type = number
}

variable "skip_final_snapshot" {
  description = "Whether to skip the final snapshot when deleting the instance"
  type = bool
}

variable "rds_tags_name" {
  description = "The name tag for the RDS instance"
  type = string
}

variable "rds_sg_name" {
  description = "The name of the security group for the RDS instance"
  type = string
}

variable "rds_sg_description" {
  description = "The description of the security group for the RDS instance"
  type = string
}

variable "rds_sg_vpc" {
  description = "The VPC ID for the security group"
  type = string
}

variable "rds_ingress_port" {
  description = "The ingress port for the RDS security group"
  type = number
  default = 5432
}

variable "rds_ingress_protocol" {
  description = "The ingress protocol for the RDS security group"
  type = string
  default = "tcp"
}

variable "rds_egress_port" {
  description = "The egress port for the RDS security group"
  type = number
  default = 0
}

variable "rds_egress_protocol" {
  description = "The egress protocol for the RDS security group"
  type = string
  default = "-1"
}

variable "rds_egress_cidr" {
  description = "The egress CIDR blocks for the RDS security group"
  type = list(string)
  default = ["0.0.0.0/0"]
}

variable "rds_sg_tags_name" {
  description = "The name tag for the RDS security group"
  type = string
}


./eks-module/outputs.tf
# output "worker_security_group_id" {
#   value = aws_security_group.eks_worker_sg.id
# }

output "worker_role_arn" {
  value = aws_iam_role.eks_worker_role.arn
}

./eks-module/workers.tf
locals {
  version = "1.29"
}
data "aws_ssm_parameter" "eks_ami_id" {
  name = "/aws/service/eks/optimized-ami/${local.version}/amazon-linux-2/recommended/image_id"
}

resource "aws_launch_template" "eks_workers" {
  name_prefix   = var.worker_lt_name_prefix
  image_id      = data.aws_ssm_parameter.eks_ami_id.value
  instance_type = var.worker_lt_inst_type

    # #!/bin/bash
    # set -o xtrace
    # /etc/eks/bootstrap.sh project-x-dev

# iam::aws:policy/AmazonEKSWorkerNodePolicy"
# iam::aws:policy/AmazonEKS_CNI_Policy"
# iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"

}

resource "aws_autoscaling_group" "eks_workers" {
  capacity_rebalance  = true
  desired_capacity    = var.worker_asg_desired_cap
  max_size            = var.worker_asg_max_size
  min_size            = var.worker_asg_min_size
  vpc_zone_identifier = var.eks_vpc_subnet_ids

  mixed_instances_policy {
    instances_distribution {
      on_demand_base_capacity                  = var.worker_asg_base_cap
      on_demand_percentage_above_base_capacity = var.worker_asg_percent_base_cap
      spot_allocation_strategy                 = var.worker_asg_spot_strategy
    }

    launch_template {
      launch_template_specification {
        launch_template_id = aws_launch_template.eks_workers.id
      }

      override {
        instance_type     = var.override_inst_type_1
        weighted_capacity = var.override_weight_cap_1
      }

      override {
        instance_type     = var.override_inst_type_2
        weighted_capacity = var.override_weight_cap_2
      }
    }
  }
}

# resource "aws_iam_role" "example" {
#   name = "eks-node-group-example"

#   assume_role_policy = jsonencode({
#     Statement = [{
#       Action = "sts:AssumeRole"
#       Effect = "Allow"
#       Principal = {
#         Service = "ec2.amazonaws.com"
#       }
#     }]
#     Version = "2012-10-17"
#   })
# }

# resource "aws_iam_role_policy_attachment" "example-AmazonEKSWorkerNodePolicy" {
#   policy_arn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
#   role       = aws_iam_role.example.name
# }

# resource "aws_iam_role_policy_attachment" "example-AmazonEKS_CNI_Policy" {
#   policy_arn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
#   role       = aws_iam_role.example.name
# }

# resource "aws_iam_role_policy_attachment" "example-AmazonEC2ContainerRegistryReadOnly" {
#   policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
#   role       = aws_iam_role.example.name
# }

./eks-module/configmap.tf
resource "kubernetes_config_map" "aws_auth" {
  metadata {
    name      = "aws-auth"
    namespace = "kube-system"
  }

  data = {
    mapRoles = <<YAML
- rolearn: ${aws_iam_role.eks_worker_role.arn}
  username: system:node:{{EC2PrivateDNSName}}
  groups:
    - system:bootstrappers
    - system:nodes
YAML
  }
}

resource "aws_iam_role" "eks_worker_role" {
  name = "eks-worker-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Service = "ec2.amazonaws.com"
        }
        Action = "sts:AssumeRole"
      },
    ]
  })

  tags = {
    Name = "eks-worker-role"
  }
}

resource "aws_iam_role_policy_attachment" "eks_worker_node_policy" {
  role       = aws_iam_role.eks_worker_role.name
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
}

resource "aws_iam_role_policy_attachment" "eks_cni_policy" {
  role       = aws_iam_role.eks_worker_role.name
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
}

resource "aws_iam_role_policy_attachment" "ec2_container_registry_readonly" {
  role       = aws_iam_role.eks_worker_role.name
  policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
}

./eks-module/variables.tf
# this is : terraform-infra-23d-vss/eks-module/variables.tf


### EKS Cluster variables ###

variable "eks_worker_role_name" {
  description = "The name of the IAM role for the EKS worker nodes"
  type        = string
  default     = "eks-worker-role"
}

variable "eks_name" {
  type    = string
  default = "project-x-dev"
}

variable "eks_version" {
  type    = string
  default = "1.29"
}

variable "eks_vpc_subnet_ids" {
  type    = list(string)
  default = ["subnet-0d5fc4ce23b5cb89a", "subnet-06e01dd0cc5e788b9"]  # Subnets in us-east-1a and us-east-1b
}

variable "k8_net_config_cidr" {
  type    = string
  default = "10.7.0.0/16"
}

variable "tag_name" {
  type    = string
  default = "project-x"
}

### Trust Policy variables ###

variable "iam_pol_effect" {
  type    = string
  default = "Allow"
}

variable "iam_pol_prin_type" {
  type    = string
  default = "Service"
}

variable "iam_pol_prin_identifiers" {
  type    = list(string)
  default = ["eks.amazonaws.com"]
}

variable "iam_pol_actions" {
  type    = list(string)
  default = ["sts:AssumeRole"]
}

### IAM role variables ###

# variable "iam_role_name" {
#   type    = string
#   default = "GitHubActionsTerraformIAMrole"  # Name of the IAM role for GitHub Actions
# }

variable "iam_role_name" {
  type    = string
  default = "project-x-dev-eks-iam-role"
}

### IAM role policy attachment variables ###

variable "iam_role_policy_arn" {
  type    = string
  default = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
}

### EKS Cluster SG variables ###

variable "eks_sg_name" {
  type    = string
  default = "EKS Cluster Security Group"
}

variable "eks_sg_description" {
  type    = string
  default = "Allow All inbound traffic from Self and all outbound traffic"
}

variable "eks_sg_vpc_id" {
  type    = string
  default = "vpc-064f95e6b9ba1df03"  # default VPC ID
}

variable "eks_sg_tag" {
  type    = map(string)
  default = {
    Name                            = "eks-cluster-sg"
    "kubernetes.io/cluster/project-x-dev" = "owned"
    "aws:eks:cluster-name"          = "project-x-dev"
  }
}

variable "sg_all_port_protocol" {
  type    = string
  default = "-1"  # semantically equivalent to all ports
}

variable "sg_all_ipv4_traffic" {
  type    = string
  default = "0.0.0.0/0"
}

variable "sg_all_ipv6_traffic" {
  type    = string
  default = "::/0"
}

variable "sg_allow_tls_port" {
  type    = number
  default = 443
}

### WORKERS variables ###

variable "worker_lt_name_prefix" {
  type    = string
  default = "project-x-eks-dev-worker-nodes"
}

variable "worker_lt_inst_type" {
  type    = string
  default = "t3.medium"
}

### Worker ASG variables ###

variable "worker_asg_desired_cap" {
  type    = number
  default = 2
}

variable "worker_asg_max_size" {
  type    = number
  default = 3
}

variable "worker_asg_min_size" {
  type    = number
  default = 1
}

### Worker ASG mixed instance policy variables ###

variable "worker_asg_base_cap" {
  type    = number
  default = 0
}

variable "worker_asg_percent_base_cap" {
  type    = number
  default = 0
}

variable "worker_asg_spot_strategy" {
  type    = string
  default = "capacity-optimized"
}

### Worker ASG launch template variables ###

variable "override_inst_type_1" {
  type    = string
  default = "t3.medium"
}

variable "override_weight_cap_1" {
  type    = string
  default = "2"
}

variable "override_inst_type_2" {
  type    = string
  default = "t2.medium"
}

variable "override_weight_cap_2" {
  type    = string
  default = "2"
}

### RDS variables ###

variable "rds_master_username" {
  description = "The master username for the RDS instance"
  type        = string
}

variable "rds_master_password" {
  description = "The master password for the RDS instance"
  type        = string
  sensitive   = true
}
./eks-module/eks.tf
resource "aws_eks_cluster" "cluster" {
  name     = var.eks_name
  role_arn = aws_iam_role.eks_cluster_role.arn
  version  = var.eks_version

  vpc_config {
    subnet_ids         = var.eks_vpc_subnet_ids
    security_group_ids = [aws_security_group.eks_cluster_sg.id]
  }

  kubernetes_network_config {
    service_ipv4_cidr = var.k8_net_config_cidr
  }

  # Ensure that IAM Role permissions are created before and deleted after EKS Cluster handling.
  # Otherwise, EKS will not be able to properly delete EKS managed EC2 infrastructure such as Security Groups.
  depends_on = [
    aws_iam_role_policy_attachment.eks_cluster_role-AmazonEKSClusterPolicy
  ]

  tags = {
    Name = var.tag_name
  }
}

# trust policy for the role
data "aws_iam_policy_document" "assume_role" {
  statement {
    effect = var.iam_pol_effect

    principals {
      type        = var.iam_pol_prin_type
      identifiers = var.iam_pol_prin_identifiers
    }

    actions = var.iam_pol_actions
  }
}

# create IAM role
resource "aws_iam_role" "eks_cluster_role" {
  name               = var.iam_role_name
  assume_role_policy = data.aws_iam_policy_document.assume_role.json
}

# attach policy to the role
resource "aws_iam_role_policy_attachment" "eks_cluster_role-AmazonEKSClusterPolicy" {
  policy_arn = var.iam_role_policy_arn
  role       = aws_iam_role.eks_cluster_role.name
}

resource "aws_security_group" "eks_cluster_sg" {
  name        = var.eks_sg_name
  description = var.eks_sg_description
  vpc_id      = var.eks_sg_vpc_id

  tags = var.eks_sg_tag
}

resource "aws_vpc_security_group_ingress_rule" "allow_tls_ipv4" {
  security_group_id             = aws_security_group.eks_cluster_sg.id
  referenced_security_group_id  = aws_security_group.eks_cluster_sg.id
  from_port                     = var.sg_allow_tls_port
  ip_protocol                   = "tcp"
  to_port                       = var.sg_allow_tls_port
}

resource "aws_vpc_security_group_egress_rule" "allow_all_traffic_ipv4" {
  security_group_id = aws_security_group.eks_cluster_sg.id
  cidr_ipv4         = var.sg_all_ipv4_traffic
  ip_protocol       = var.sg_all_port_protocol
}

resource "aws_vpc_security_group_egress_rule" "allow_all_traffic_ipv6" {
  security_group_id = aws_security_group.eks_cluster_sg.id
  cidr_ipv6         = var.sg_all_ipv6_traffic
  ip_protocol       = var.sg_all_port_protocol
}

# Define the eks_worker_sg resource
resource "aws_security_group" "eks_worker_sg" {
  name        = "eks-worker-sg"
  description = "Security group for EKS worker nodes"
  vpc_id      = var.eks_sg_vpc_id

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "eks-worker-sg"
  }
}

output "endpoint" {
  value = aws_eks_cluster.cluster.endpoint
}

output "kubeconfig-certificate-authority-data" {
  value = aws_eks_cluster.cluster.certificate_authority[0].data
}

output "worker_security_group_id" {
  value = [aws_security_group.eks_worker_sg.id]
}

# The following resources were commented out:
# 
# resource "aws_iam_role" "example" {
#   name = "eks-node-group-example"
# 
#   assume_role_policy = jsonencode({
#     Statement = [{
#       Action = "sts:AssumeRole"
#       Effect = "Allow"
#       Principal = {
#         Service = "ec2.amazonaws.com"
#       }
#     }]
#     Version = "2012-10-17"
#   })
# }
# 
# resource "aws_iam_role_policy_attachment" "example-AmazonEKSWorkerNodePolicy" {
#   policy_arn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
#   role       = aws_iam_role.example.name
# }
# 
# resource "aws_iam_role_policy_attachment" "example-AmazonEKS_CNI_Policy" {
#   policy_arn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
#   role       = aws_iam_role.example.name
# }
# 
# resource "aws_iam_role_policy_attachment" "example-AmazonEC2ContainerRegistryReadOnly" {
#   policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
#   role       = aws_iam_role.example.name
# }

./root/main-eks-root/main.tf
module "project-x-eks-cluster" {
  source = "../../eks-module"

  ### eks.tf ###
  eks_name                  = var.eks_name
  eks_version               = var.eks_version
  eks_vpc_subnet_ids        = var.eks_vpc_subnet_ids
  k8_net_config_cidr        = var.k8_net_config_cidr
  tag_name                  = var.tag_name
  iam_pol_effect            = var.iam_pol_effect
  iam_pol_prin_type         = var.iam_pol_prin_type
  iam_pol_prin_identifiers  = var.iam_pol_prin_identifiers
  iam_pol_actions           = var.iam_pol_actions
  iam_role_name             = var.iam_role_name
  iam_role_policy_arn       = var.iam_role_policy_arn
  eks_sg_name               = var.eks_sg_name
  eks_sg_description        = var.eks_sg_description
  eks_sg_vpc_id             = var.eks_sg_vpc_id
  eks_sg_tag                = var.eks_sg_tag
  sg_allow_tls_port         = var.sg_allow_tls_port
  sg_all_ipv4_traffic       = var.sg_all_ipv4_traffic
  sg_all_port_protocol      = var.sg_all_port_protocol
  sg_all_ipv6_traffic       = var.sg_all_ipv6_traffic
  eks_worker_role_name      = var.eks_worker_role_name

  ### workers.tf ###
  worker_lt_name_prefix     = var.worker_lt_name_prefix
  worker_lt_inst_type       = var.worker_lt_inst_type
  worker_asg_desired_cap    = var.worker_asg_desired_cap
  worker_asg_max_size       = var.worker_asg_max_size
  worker_asg_min_size       = var.worker_asg_min_size
  worker_asg_base_cap       = var.worker_asg_base_cap
  worker_asg_percent_base_cap = var.worker_asg_percent_base_cap
  worker_asg_spot_strategy  = var.worker_asg_spot_strategy
  override_inst_type_1      = var.override_inst_type_1
  override_weight_cap_1     = var.override_weight_cap_1
  override_inst_type_2      = var.override_inst_type_2
  override_weight_cap_2     = var.override_weight_cap_2

  ### rds.tf ###
  rds_master_username       = var.rds_master_username
  rds_master_password       = var.rds_master_password
}

module "rds_postgres" {
  source = "../../rds-postgres-module"

  eks_cluster_sg_id           = module.project-x-eks-cluster.worker_security_group_id
  subnet_ids                  = ["subnet-0d5fc4ce23b5cb89a", "subnet-06e01dd0cc5e788b9"]  # Subnets in us-east-1a and us-east-1b
  allocated_storage           = 20
  storage_type                = "gp2"
  engine                      = "postgres"
  engine_version              = "16.2"
  instance_class              = "db.t3.micro"
  db_name                     = "reviews_app_data"
  identifier                  = "reviews-app-db"
  rds_master_username         = var.rds_master_username
  rds_master_password         = var.rds_master_password
  manage_master_user_password = true
  backup_retention_period     = 7
  skip_final_snapshot         = true
  rds_tags_name               = "reviews-app-db"
  rds_sg_name                 = "rds-postgres-sg"
  rds_sg_description          = "Security group for RDS PostgreSQL"
  rds_sg_vpc                  = "vpc-064f95e6b9ba1df03"
  rds_ingress_port            = 5432
  rds_ingress_protocol        = "tcp"
  rds_egress_port             = 0
  rds_egress_protocol         = "-1"
  rds_egress_cidr             = ["0.0.0.0/0"]
  rds_sg_tags_name            = "rds-postgres-sg"
}

./root/main-eks-root/providers.tf
# Providers.tf
provider "aws" {
  region = "us-east-1"
}

terraform {
  backend "s3" {
    bucket  = "githubactions-terraform-task"
    key     = "terraform.tfstate"
    region  = "us-east-1"
    encrypt = true
  }
}

provider "kubernetes" {
  host                   = module.project-x-eks-cluster.endpoint
  cluster_ca_certificate = base64decode(module.project-x-eks-cluster.kubeconfig-certificate-authority-data)
  token                  = data.aws_eks_cluster_auth.cluster.token
}

data "aws_eks_cluster_auth" "cluster" {
  name = var.eks_name
}

./root/main-eks-root/mainvars.tf
#  this is : root/main-eks-root/mainvars.tf


### EKS Cluster variables ###

variable "eks_worker_role_name" {
  description = "The name of the IAM role for the EKS worker nodes"
  type        = string
  default     = "eks-worker-role"
}

variable "eks_name" {
  type    = string
  default = "project-x-dev"
}

variable "eks_version" {
  type    = string
  default = "1.29"
}

variable "eks_vpc_subnet_ids" {
  type    = list(string)
  default = ["subnet-0d5fc4ce23b5cb89a", "subnet-06e01dd0cc5e788b9"]
}

variable "k8_net_config_cidr" {
  type    = string
  default = "10.7.0.0/16"
}

variable "tag_name" {
  type    = string
  default = "project-x"
}

### Trust Policy variables ###

variable "iam_pol_effect" {
  type    = string
  default = "Allow"
}

variable "iam_pol_prin_type" {
  type    = string
  default = "Service"
}

variable "iam_pol_prin_identifiers" {
  type    = list(string)
  default = ["eks.amazonaws.com"]
}

variable "iam_pol_actions" {
  type    = list(string)
  default = ["sts:AssumeRole"]
}

### IAM role variables ###


# variable "iam_role_name" {
#   type = string
#   default = "GitHubActionsTerraformIAMrole"  # Name of the IAM role for GitHub Actions
# }



variable "iam_role_name" {
  type    = string
  default = "project-x-dev-eks-iam-role"
}

### IAM role policy attachment variables ###

variable "iam_role_policy_arn" {
  type    = string
  default = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
}

### EKS Cluster SG variables ###

variable "eks_sg_name" {
  type    = string
  default = "EKS Cluster Security Group"
}

variable "eks_sg_description" {
  type    = string
  default = "Allow All inbound traffic from Self and all outbound traffic"
}

variable "eks_sg_vpc_id" {
  type    = string
  default = "vpc-064f95e6b9ba1df03"  # default VPC ID
}

variable "eks_sg_tag" {
  type    = map(string)
  default = {
    Name                            = "eks-cluster-sg"
    "kubernetes.io/cluster/project-x-dev" = "owned"
    "aws:eks:cluster-name"          = "project-x-dev"
  }
}

variable "sg_all_port_protocol" {
  type    = string
  default = "-1" # semantically equivalent to all ports
}

variable "sg_all_ipv4_traffic" {
  type    = string
  default = "0.0.0.0/0"
}

variable "sg_all_ipv6_traffic" {
  type    = string
  default = "::/0"
}

variable "sg_allow_tls_port" {
  type    = number
  default = 443
}

### WORKERS variables ###

variable "worker_lt_name_prefix" {
  type    = string
  default = "project-x-eks-dev-worker-nodes"
}

variable "worker_lt_inst_type" {
  type    = string
  default = "t3.medium"
}

### Worker ASG variables ###

variable "worker_asg_desired_cap" {
  type    = number
  default = 2
}

variable "worker_asg_max_size" {
  type    = number
  default = 3
}

variable "worker_asg_min_size" {
  type    = number
  default = 1
}

### Worker ASG mixed instance policy variables ###

variable "worker_asg_base_cap" {
  type    = number
  default = 0
}

variable "worker_asg_percent_base_cap" {
  type    = number
  default = 0
}

variable "worker_asg_spot_strategy" {
  type    = string
  default = "capacity-optimized"
}

### Worker ASG launch template variables ###

variable "override_inst_type_1" {
  type    = string
  default = "t3.medium"
}

variable "override_weight_cap_1" {
  type    = string
  default = "2"
}

variable "override_inst_type_2" {
  type    = string
  default = "t2.medium"
}

variable "override_weight_cap_2" {
  type    = string
  default = "2"
}

variable "rds_master_username" {
  description = "The master username for the RDS instance"
  type        = string
}

variable "rds_master_password" {
  description = "The master password for the RDS instance"
  type        = string
  sensitive   = true
}
