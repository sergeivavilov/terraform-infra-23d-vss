module.project-x-eks-cluster.data.aws_ssm_parameter.eks_ami_id: Reading...
module.project-x-eks-cluster.data.aws_iam_policy_document.assume_role: Reading...
module.project-x-eks-cluster.data.aws_iam_policy_document.assume_role: Read complete after 0s [id=3552664922]
module.project-x-eks-cluster.data.aws_ssm_parameter.eks_ami_id: Read complete after 1s [id=/aws/service/eks/optimized-ami/1.29/amazon-linux-2/recommended/image_id]

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # module.project-x-eks-cluster.aws_autoscaling_group.eks_workers will be created
  + resource "aws_autoscaling_group" "eks_workers" {
      + arn                              = (known after apply)
      + availability_zones               = (known after apply)
      + capacity_rebalance               = true
      + default_cooldown                 = (known after apply)
      + desired_capacity                 = 2
      + force_delete                     = false
      + force_delete_warm_pool           = false
      + health_check_grace_period        = 300
      + health_check_type                = (known after apply)
      + id                               = (known after apply)
      + ignore_failed_scaling_activities = false
      + load_balancers                   = (known after apply)
      + max_size                         = 3
      + metrics_granularity              = "1Minute"
      + min_size                         = 1
      + name                             = (known after apply)
      + name_prefix                      = (known after apply)
      + predicted_capacity               = (known after apply)
      + protect_from_scale_in            = false
      + service_linked_role_arn          = (known after apply)
      + target_group_arns                = (known after apply)
      + vpc_zone_identifier              = [
          + "subnet-06e01dd0cc5e788b9",
          + "subnet-0d5fc4ce23b5cb89a",
        ]
      + wait_for_capacity_timeout        = "10m"
      + warm_pool_size                   = (known after apply)

      + mixed_instances_policy {
          + instances_distribution {
              + on_demand_allocation_strategy            = (known after apply)
              + on_demand_base_capacity                  = 0
              + on_demand_percentage_above_base_capacity = 0
              + spot_allocation_strategy                 = "capacity-optimized"
              + spot_instance_pools                      = 0
            }
          + launch_template {
              + launch_template_specification {
                  + launch_template_id   = (known after apply)
                  + launch_template_name = (known after apply)
                  + version              = (known after apply)
                }
              + override {
                  + instance_type     = "t3.medium"
                  + weighted_capacity = "2"
                }
              + override {
                  + instance_type     = "t2.medium"
                  + weighted_capacity = "2"
                }
            }
        }
    }

  # module.project-x-eks-cluster.aws_eks_cluster.cluster will be created
  + resource "aws_eks_cluster" "cluster" {
      + arn                   = (known after apply)
      + certificate_authority = (known after apply)
      + cluster_id            = (known after apply)
      + created_at            = (known after apply)
      + endpoint              = (known after apply)
      + id                    = (known after apply)
      + identity              = (known after apply)
      + name                  = "project-x-dev"
      + platform_version      = (known after apply)
      + role_arn              = (known after apply)
      + status                = (known after apply)
      + tags                  = {
          + "Name" = "project-x"
        }
      + tags_all              = {
          + "Name" = "project-x"
        }
      + version               = "1.29"

      + kubernetes_network_config {
          + ip_family         = (known after apply)
          + service_ipv4_cidr = "10.7.0.0/16"
          + service_ipv6_cidr = (known after apply)
        }

      + vpc_config {
          + cluster_security_group_id = (known after apply)
          + endpoint_private_access   = false
          + endpoint_public_access    = true
          + public_access_cidrs       = (known after apply)
          + security_group_ids        = (known after apply)
          + subnet_ids                = [
              + "subnet-06e01dd0cc5e788b9",
              + "subnet-0d5fc4ce23b5cb89a",
            ]
          + vpc_id                    = (known after apply)
        }
    }

  # module.project-x-eks-cluster.aws_iam_role.eks_cluster_role will be created
  + resource "aws_iam_role" "eks_cluster_role" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "eks.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "project-x-dev-eks-iam-role"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)
    }

  # module.project-x-eks-cluster.aws_iam_role_policy_attachment.eks_cluster_role-AmazonEKSClusterPolicy will be created
  + resource "aws_iam_role_policy_attachment" "eks_cluster_role-AmazonEKSClusterPolicy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
      + role       = "project-x-dev-eks-iam-role"
    }

  # module.project-x-eks-cluster.aws_launch_template.eks_workers will be created
  + resource "aws_launch_template" "eks_workers" {
      + arn             = (known after apply)
      + default_version = (known after apply)
      + id              = (known after apply)
      + image_id        = (sensitive value)
      + instance_type   = "t3.medium"
      + latest_version  = (known after apply)
      + name            = (known after apply)
      + name_prefix     = "project-x-eks-dev-worker-nodes"
      + tags_all        = (known after apply)
    }

  # module.project-x-eks-cluster.aws_security_group.eks_cluster_sg will be created
  + resource "aws_security_group" "eks_cluster_sg" {
      + arn                    = (known after apply)
      + description            = "Allow All inbound traffic from Self and all outbound traffic"
      + egress                 = (known after apply)
      + id                     = (known after apply)
      + ingress                = (known after apply)
      + name                   = "EKS Cluster Security Group"
      + name_prefix            = (known after apply)
      + owner_id               = (known after apply)
      + revoke_rules_on_delete = false
      + tags                   = {
          + "Name"                                = "eks-cluster-sg"
          + "aws:eks:cluster-name"                = "project-x-dev"
          + "kubernetes.io/cluster/project-x-dev" = "owned"
        }
      + tags_all               = {
          + "Name"                                = "eks-cluster-sg"
          + "aws:eks:cluster-name"                = "project-x-dev"
          + "kubernetes.io/cluster/project-x-dev" = "owned"
        }
      + vpc_id                 = "vpc-064f95e6b9ba1df03"
    }

  # module.project-x-eks-cluster.aws_vpc_security_group_egress_rule.allow_all_traffic_ipv4 will be created
  + resource "aws_vpc_security_group_egress_rule" "allow_all_traffic_ipv4" {
      + arn                    = (known after apply)
      + cidr_ipv4              = "0.0.0.0/0"
      + id                     = (known after apply)
      + ip_protocol            = "-1"
      + security_group_id      = (known after apply)
      + security_group_rule_id = (known after apply)
      + tags_all               = {}
    }

  # module.project-x-eks-cluster.aws_vpc_security_group_egress_rule.allow_all_traffic_ipv6 will be created
  + resource "aws_vpc_security_group_egress_rule" "allow_all_traffic_ipv6" {
      + arn                    = (known after apply)
      + cidr_ipv6              = "::/0"
      + id                     = (known after apply)
      + ip_protocol            = "-1"
      + security_group_id      = (known after apply)
      + security_group_rule_id = (known after apply)
      + tags_all               = {}
    }

  # module.project-x-eks-cluster.aws_vpc_security_group_ingress_rule.allow_tls_ipv4 will be created
  + resource "aws_vpc_security_group_ingress_rule" "allow_tls_ipv4" {
      + arn                          = (known after apply)
      + from_port                    = 0
      + id                           = (known after apply)
      + ip_protocol                  = "tcp"
      + referenced_security_group_id = (known after apply)
      + security_group_id            = (known after apply)
      + security_group_rule_id       = (known after apply)
      + tags_all                     = {}
      + to_port                      = 0
    }

Plan: 9 to add, 0 to change, 0 to destroy.

─────────────────────────────────────────────────────────────────────────────

Saved the plan to: tfplan

To perform exactly these actions, run the following command to apply:
    terraform apply "tfplan"
